{"list":[{"title":"本blog文章新建工具","filename":"article-build-tools","content":"本工具基于node,使用\"node createArticle.js\"启动(可能需要sudo权限)，启动后，访问127.0.0.1/add 来添加文章，其中：<br>\r\n * add.tpl为添加操作页面的模板<br>\r\n * indextmp.tpl为首页模板<br>\r\n * template.tpl为文章模板 <br>\r\n * articlelist.json为已建文章列表<br>\r\n\r\n所有文章将被创建到page目录下，同时将更新首页文章列表，并将创建记录存储在articlelist.json文件中.<br>\r\n删除操作只需将page路径下的文章删除，同时删除文章在acticlelist.json中的记录"},{"title":"web性能优化整理","filename":"better-web","content":"抽时间整理了下web性能优化的一些知识点，具体内容见下图<br>\r\n<img src=\"http://ww1.sinaimg.cn/large/e59a5c27jw1esd8cd0hq3j20pi0pbq71.jpg\" style=\"width: 100%;\">"},{"title":"关于HTTP的请求方式","filename":"http-request-types","content":"说到Http请求方式，基本上很多前端都能反应到GET与POST两种，未查资料之前，我也只知道这两种方式，事实上，HTTP协议中处理这两种请求方式之外，还有几种我们作为前端平时见得比较少的方式，以下是这几种方式的说明：<br>\r\n1. GET: 请求获取由Request-URI所标识的资源；<br>\r\n2. POST: 在Request-URI所标识的资源后附加新的数据；<br>\r\n3. HEAD: 请求获取有Request-URI所标识的资源的响应消息报头，可用来获取头信息或元数据；<br>\r\n4. OPTIONS: 请求查询服务器的性能，或查询与资源相关的选项和需求；<br>\r\n5. PUT: 请求服务器存储一个资源，并用Request-URI作为其标识；<br>\r\n6. DELETE: 请求服务器删除有Request-URI所标识的资源；<br>\r\n7. TRACE: 请求服务器回送收到的请求信息，主要用于测试或诊断，就像Ping环回地址检测TCP/IP协议一样。<br>\r\n<br>\r\n以上，如有错误，敬请指出。"},{"title":"ES6新特性说明","filename":"ecma-script6","content":"<p class=\"p1\"><span class=\"s1\">1. 箭头函数(FF已支持)；</span></p>\r\n<p class=\"p1\"><span class=\"s1\">可看做是函数的一种，举例如下：</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var fn = (x = 1, y = 1) =&gt; (x + y);</span></p>\r\n<p class=\"p1\"><span class=\"s1\">等效于：</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var fn = (x = 1, y = 1) =&gt; {return (x + y);};</span></p>\r\n<p class=\"p1\"><span class=\"s1\">// var fn = function (x, y) {x = x || 1; y = y || 1; return x + y;}</span></p>\r\n<p class=\"p1\"><span class=\"s1\">// 无参数的情况</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var sayHi = () =&gt; {return ‘Hi’;};</span></p>\r\n<p class=\"p2\"><span class=\"s1\"></span><br></p>\r\n<p class=\"p1\"><span class=\"s1\">使用方法同传统的函数调用一样。</span></p>\r\n<p class=\"p3\"><span class=\"s1\"><b>关于this，箭头函数的this始终指向函数定义时的this.</b></span></p>\r\n<p class=\"p3\"><span class=\"s1\"><b>且其内部无[Construct]和属性原型，所以不能进行new 实例化操作</b></span></p>\r\n<p class=\"p4\"><span class=\"s1\"><b></b></span><br></p>\r\n<p class=\"p1\"><span class=\"s1\">2. 增强的对象字面量形式：</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var obj = {</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span>__proto__: 可直接在构建时设置原型,</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span>// handler: handler的简写形式</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span>handler,</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span>// 方法定义</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span>toString () {</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span><span class=\"Apple-tab-span\">\t</span>// super调用，代表其继承类</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span><span class=\"Apple-tab-span\">\t</span>return ‘d ‘ + super.toString();</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span>},</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span>// 动态设置属性名称</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span>[‘prop_’ + (() =&gt; 66)()]: 66</span></p>\r\n<p class=\"p1\"><span class=\"s1\">};</span></p>\r\n<p class=\"p2\"><span class=\"s1\"></span><br></p>\r\n<p class=\"p1\"><span class=\"s1\">3. 模板字符串Template Strings</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var content = ’string content.’;</span></p>\r\n<p class=\"p1\"><span class=\"s1\">`This is a string, which content is ${content}`</span></p>\r\n<p class=\"p1\"><span class=\"s1\">tempHandler`This is a string:${content}`;</span></p>\r\n<p class=\"p2\"><span class=\"s1\"></span><br></p>\r\n<p class=\"p1\"><span class=\"s1\">4. 解构：</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var [a, b] = [1, 2];</span></p>\r\n<p class=\"p1\"><span class=\"s1\">等同于var a = 1, b = 2;</span></p>\r\n<p class=\"p2\"><span class=\"s1\"></span><br></p>\r\n<p class=\"p1\"><span class=\"s1\">var {var1: v1, var2: v2, varN: vNo, vDefault: vD = 4} = {var1: 1, var2: 2};</span></p>\r\n<p class=\"p1\"><span class=\"s1\">等同于</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var v1 = 1, v2 = 2, vNo = undefined, vD = (typeof obj.vDefault != ‘undefined’)? obj.vDefault : 4;// 失效弱化</span></p>\r\n<p class=\"p2\"><span class=\"s1\"></span><br></p>\r\n<p class=\"p1\"><span class=\"s1\">5. Default + Rest + Spread 默认值+多余参数组合+参数伸展</span></p>\r\n<p class=\"p1\"><span class=\"s1\">举例：</span></p>\r\n<p class=\"p1\"><span class=\"s1\">// 默认值类似于PHP</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var fn = function (a, b = 3) {console.log(a + b);};</span></p>\r\n<p class=\"p1\"><span class=\"s1\">fn(1);// 4</span></p>\r\n<p class=\"p1\"><span class=\"s1\">// 多余参数组合</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var fn = function (x, …y) {console.log(x + y);};</span></p>\r\n<p class=\"p1\"><span class=\"s1\">fn(1, 2, 3, 4); // 1 + 4 = 5</span></p>\r\n<p class=\"p2\"><span class=\"s1\"></span><br></p>\r\n<p class=\"p1\"><span class=\"s1\">// 参数伸展</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var fn = function (x, y, z) {return x + y + z;};</span></p>\r\n<p class=\"p1\"><span class=\"s1\">fn(…[1, 2, 3]);// 6</span></p>\r\n<p class=\"p2\"><span class=\"s1\"></span><br></p>\r\n<p class=\"p1\"><span class=\"s1\">6. let与const操作符</span></p>\r\n<p class=\"p1\"><span class=\"s1\">两者都只在块级作用域内有效，其中let可看做是新的var操作符，用于声明块级作用域下的变量，const声明的是块级作用域的常量，声明之后不可再进行赋值，也不能进行let操作(常量，这点同PHP)。</span></p>\r\n<p class=\"p2\"><span class=\"s1\"></span><br></p>\r\n<p class=\"p1\"><span class=\"s1\">7. for … of</span></p>\r\n<p class=\"p1\"><span class=\"s1\">例如：</span></p>\r\n<p class=\"p1\"><span class=\"s1\">var arr = [1, 2, 3]</span></p>\r\n<p class=\"p1\"><span class=\"s1\">for(var i of arr) {</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span>// xxx</span></p>\r\n<p class=\"p1\"><span class=\"s1\">}</span></p>\r\n<p class=\"p1\"><span class=\"s1\">等同于：</span></p>\r\n<p class=\"p1\"><span class=\"s1\">for (var i = 0, aL = arr.length; i &lt; aL; i++) {</span></p>\r\n<p class=\"p1\"><span class=\"s1\"><span class=\"Apple-tab-span\">\t</span>// xxx</span></p>\r\n<p class=\"p1\"><span class=\"s1\">}</span></p>\r\n<p class=\"p1\"><span class=\"s1\">To be continued...</span></p>"},{"title":"表单提交过程分析","filename":"form-submit-proccess","content":"<p class=\"p1\"><span class=\"s1\">关于表单提交：</span></p><p class=\"p1\"><span class=\"s1\"><b><i>第一个过程</i></b>： successful controls;</span></p><p class=\"p1\"><span class=\"s1\">controls说明：</span></p><p class=\"p1\"><span class=\"s1\">推测应该是一个能被成功提交的表单控件，例如开启的checkboxes，同name的radio中被开启的那个。</span></p><p class=\"p1\"><span class=\"s1\">successful controls 是指可以有效的提交的控件。</span></p><p class=\"p1\"><span class=\"s1\">每一个 successful controls 均具备由其 name 属性（control name）及当前 value 属性（current value）所组成的“name/value”键值对，这些 successful controls 的键值对组成了 form data set。</span></p><p class=\"p1\"><span class=\"s1\">而 W3C 规定，定义在 FORM 元素内的 successful controls 必须拥有 name 属性。a. 如果一个表单里面包含多个提交按钮时，只有被激活的那个按钮才能提交成功；&nbsp;</span></p><p class=\"p2\"><span class=\"s1\"></span><br></p><p class=\"p1\"><span class=\"s1\"><b><i>第二个过程</i></b>：根据第一个过程的successful controls来创建表单数据集(form data set, 一个键值对序列)；</span></p><p class=\"p2\"><span class=\"s1\"></span><br></p><p class=\"p1\"><span class=\"s1\"><b><i>第三个过程</i></b>：根据form元素的enctype属性所指定的content type来对第二个过程的数据集进行编码；</span></p><p class=\"p2\"><span class=\"s1\"></span><br></p><p class=\"p1\"><span class=\"s1\"><b><i>第四个过程</i></b>：根据form元素的method属性指定的协议，将编码后的数据集发送到action属性指定的目标处理代理上。</span></p>"}]}